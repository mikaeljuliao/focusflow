<!-- #region 
 

ðŸ§‘â€ðŸ« Aula: â€œCriar tarefa â†’ Adicionar â†’ Renderizar listaâ€ â€” explicaÃ§Ã£o completa
1) VisÃ£o geral (o objetivo)

Queremos um fluxo simples e previsÃ­vel:
1. O usuÃ¡rio digita a descriÃ§Ã£o e escolhe a prioridade.
2. O usuÃ¡rio clica em Adicionar tarefa.
3. A tarefa sÃ³ entÃ£o entra em um array de tarefas no estado.
4. O React renderiza a lista (um item por tarefa) â€” no nosso caso, na div da direita.

Pontos-chave: estado, imutabilidade, renderizaÃ§Ã£o via map, inputs controlados.


2) CÃ³digo final que usamos (referÃªncia rÃ¡pida):

Copie isso pro seu projeto se quiser revisar enquanto lÃª a aula:

import React, { useState } from "react";

export default function TarefasDiarias() {
  const [descricao, setDescricao] = useState("");
  const [prioridade, setPrioridade] = useState("MÃ©dia");
  const [tarefas, setTarefas] = useState([]);

  function adicionarTarefa() {
    if (!descricao.trim()) return; // evita adicionar vazio

    const nova = { descricao, prioridade };
    setTarefas([...tarefas, nova]); // espalha o array antigo e adiciona a nova tarefa

    setDescricao(""); // limpa input
    setPrioridade("MÃ©dia"); // reseta prioridade
  }

  return (
    <div>
      {/* inputs controlados */}
      <input value={descricao} onChange={(e) => setDescricao(e.target.value)} />
      <select value={prioridade} onChange={(e) => setPrioridade(e.target.value)}>
        <option>Alta</option><option>MÃ©dia</option><option>Baixa</option>
      </select>
      <button onClick={adicionarTarefa}>Adicionar tarefa</button>

      {/* lista */}
      <ul>
        {tarefas.map((t, i) => (
          <li key={i}>
            <strong>{t.descricao}</strong> â€” {t.prioridade}
          </li>
        ))}
      </ul>
    </div>
  );
}




3) Conceitos fundamentais (para entender tudo):

a) Estado (state):
. useState cria um pedaÃ§o de estado no componente.
. Ex.: const [tarefas, setTarefas] = useState([]) cria um array vazio que representa a lista.
. Sempre que chamamos setTarefas(...), o componente re-renderiza com o novo valor.

b) Imutabilidade:
. No React nÃ£o alteramos o estado diretamente. NÃƒO faÃ§a tarefas.push(...).
. Em vez disso, criamos uma nova cÃ³pia do array com a alteraÃ§Ã£o e chamamos setTarefas(novoArray).
. Ex.: setTarefas([...tarefas, novaTarefa]) â†’ usa o spread operator ... 
para copiar elementos antigos e acrescentar a nova tarefa.

c) Inputs controlados:
. Um input controlado tem seu valor controlado pelo estado:
. value={descricao} e onChange={e => setDescricao(e.target.value)}
. Isso garante que o valor do campo e o estado estejam sincronizados.

d) RenderizaÃ§Ã£o de listas:
. Para renderizar a lista: tarefas.map((tarefa, i) => (...))
. Importante: o key ajuda o React a identificar itens entre renders. 
Use id Ãºnico se tiver; index funciona em listas pequenas/imutÃ¡veis.



4) ExplicaÃ§Ã£o linha a linha (lÃ³gica central):

Vamos dissecar a funÃ§Ã£o adicionarTarefa â€” o nÃºcleo da funcionalidade:

function adicionarTarefa() {
  if (!descricao.trim()) return;
  const nova = { descricao, prioridade };
  setTarefas([...tarefas, nova]);
  setDescricao("");
  setPrioridade("MÃ©dia");
}


. if (!descricao.trim()) return;
â†’ evita tarefas vazias. trim() remove espaÃ§os no comeÃ§o/fim.

. const nova = { descricao, prioridade };
â†’ cria um objeto com os valores atuais dos inputs.
ObservaÃ§Ã£o: descricao e prioridade aqui sÃ£o variÃ¡veis (estados) que sempre contÃªm 
o valor mais atual porque sÃ£o atualizados por onChange.

. setTarefas([...tarefas, nova]);
â†’ cria um novo array copiando todos os itens de tarefas (com ...tarefas) e adiciona nova no final.
Isso faz com que React saiba que o array mudou e re-renderize.

. setDescricao(""); setPrioridade("MÃ©dia");
â†’ limpa os inputs para permitir criar a prÃ³xima tarefa com facilidade.

5) Por que o spread [...] Ã© necessÃ¡rio? (detalhe importante):

- ...tarefas expande/copia cada item do array anterior dentro do novo array:
Ex.: se tarefas = [A,B] entÃ£o [...tarefas, C] vira [A,B,C].

- Se fizÃ©ssemos tarefas.push(C) estarÃ­amos mutando o array original, o que 
Ã© antipadrÃ£o no React e pode causar bugs e renderizaÃ§Ãµes inesperadas.


6) Control flow e re-render (o que acontece quando clico no botÃ£o):
1. UsuÃ¡rio clica em â€œAdicionar tarefaâ€.
2. adicionarTarefa() executa:
  . validaÃ§Ã£o
  . cria nova
  . chama setTarefas([...tarefas, nova])
3. Ao chamar setTarefas, React agenda uma atualizaÃ§Ã£o de estado.
4. React re-renderiza o componente com o novo tarefas.
5. No return, tarefas.map(...) agora tem um item a mais â†’ Ã© renderizado na lista.
6 .Inputs sÃ£o limpos (porque os estados descricao e prioridade foram resetados).



7) Tratamento de valores atualizados (por que descriÃ§Ã£o tem o valor certo):
. Os inputs sÃ£o controlados (value + onChange). Isso significa que quando o usuÃ¡rio digita, 
setDescricao atualiza imediatamente o estado.
. Quando adicionarTarefa Ã© chamado, ele lÃª os estados descricao e prioridade que 
jÃ¡ refletem o que o usuÃ¡rio digitou.
. Portanto, const nova = { descricao, prioridade } pega os valores corretos.


8) Boas prÃ¡ticas e melhorias:
a) Evitar usar index como key quando houver reordenamento/exclusÃ£o:
. Se o usuÃ¡rio puder remover ou reordenar tarefas, prefira id Ãºnico (por exemplo Date.now() 
ou crypto.randomUUID()):

const nova = { id: Date.now(), descricao, prioridade };
setTarefas([...tarefas, nova]);

e no map: key={t.id}

b) Validar e mostrar erro ao usuÃ¡rio:
. Se o input estiver vazio, mostrar um feedback (toast, texto vermelho), em vez de return silencioso.


c) PersistÃªncia (LocalStorage):
. Para manter tarefas apÃ³s reload:

useEffect(() => {
  const fromStorage = JSON.parse(localStorage.getItem("tarefas") || "[]");
  setTarefas(fromStorage);
}, []);

useEffect(() => {
  localStorage.setItem("tarefas", JSON.stringify(tarefas));
}, [tarefas]);


d) Remover e editar:
. Remover: setTarefas(tarefas.filter(t => t.id !== idParaRemover))
. Editar: map e substituir item pelo novo objeto


e) useReducer (quando a lÃ³gica crescer):
. Se muitas aÃ§Ãµes (adicionar, remover, editar, toggle completo), useReducer dÃ¡ mais clareza.




9) PossÃ­veis bugs e como debugar:

Bug: tarefa aparece vazia:
. Causa comum: adicionarTarefa foi acionada antes do onChange finalizar 
(rarÃ­ssimo com controlled inputs) â€” normalmente porque nÃ£o usou value no input.
. SoluÃ§Ã£o: sempre value={descricao} e onChange.

Bug: lista nÃ£o atualiza:
. Causa: mutaÃ§Ã£o do array (usou push em vez de novo array).
. SoluÃ§Ã£o: sempre criar novo array ([...] ou map / filter / concat).

Bug: elementos trocando de lugar estranhamente:
. Causa: usar Ã­ndice como key ao remover/reordenar.
. SoluÃ§Ã£o: use key estÃ¡vel (id Ãºnico).




10) ExercÃ­cios prÃ¡ticos para fixar (faÃ§a vocÃª mesmo):
1. Altere adicionarTarefa para gerar id: Date.now() para cada tarefa.
2. Implemente um botÃ£o â€œRemoverâ€ em cada item que use filter para excluir.
3. Salve as tarefas no localStorage e recupere no useEffect.
4. Troque para useReducer quando tiver as aÃ§Ãµes: add, remove, edit, toggleDone.
5. Adicione validaÃ§Ã£o visual (texto vermelho) quando a descriÃ§Ã£o for vazia.



11) Checklist rÃ¡pido (resumo que vocÃª pode colar no README):
. Inputs sÃ£o controlados (value + onChange)
. Estado para inputs temporÃ¡rios: descricao, prioridade
. Estado para lista final: tarefas (array de objetos)
. adicionarTarefa cria nova = { descricao, prioridade, id }
. Atualiza lista com setTarefas([...tarefas, nova])
. Limpa inputs com setDescricao("")
. Renderiza lista com tarefas.map(...) usando key Ãºnico
. NÃ£o mutar arrays (nunca usar push no estado)



12) Porque vocÃª travou antes (resposta direta ao seu pensamento):
VocÃª pensou em criar nova = { descricao, prioridade }, mas nÃ£o 
sabia onde encaixar isso. A linha Ã© simples â€” o ponto mais difÃ­cil 
Ã© entender quando e como colocar isso no estado:
. Quando? â†’ no clique do botÃ£o Adicionar.
. Como? â†’ com setTarefas([...tarefas, nova]).
. Por que? â†’ porque assim vocÃª adiciona ao array sem mutÃ¡-lo e forÃ§a o React a re-renderizar.



13) Exemplo estendido com remoÃ§Ã£o, id e localStorage (pronto para colar):
import React, { useState, useEffect } from "react";

export default function TarefasDiarias() {
  const [descricao, setDescricao] = useState("");
  const [prioridade, setPrioridade] = useState("MÃ©dia");
  const [tarefas, setTarefas] = useState([]);

  // Recupera do localStorage ao montar
  useEffect(() => {
    const saved = JSON.parse(localStorage.getItem("tarefas") || "[]");
    setTarefas(saved);
  }, []);

  // Salva no localStorage sempre que tarefas mudarem
  useEffect(() => {
    localStorage.setItem("tarefas", JSON.stringify(tarefas));
  }, [tarefas]);

  function adicionarTarefa() {
    if (!descricao.trim()) return;
    const nova = { id: Date.now(), descricao, prioridade };
    setTarefas((prev) => [...prev, nova]); // usando functional update Ã© ainda mais seguro
    setDescricao("");
    setPrioridade("MÃ©dia");
  }

  function removerTarefa(id) {
    setTarefas((prev) => prev.filter(t => t.id !== id));
  }

  return (
    <div>
      <input value={descricao} onChange={e => setDescricao(e.target.value)} />
      <select value={prioridade} onChange={e => setPrioridade(e.target.value)}>
        <option>Alta</option><option>MÃ©dia</option><option>Baixa</option>
      </select>
      <button onClick={adicionarTarefa}>Adicionar</button>

      <ul>
        {tarefas.map(t => (
          <li key={t.id}>
            <strong>{t.descricao}</strong> â€” {t.prioridade}
            <button onClick={() => removerTarefa(t.id)}>Remover</button>
          </li>
        ))}
      </ul>
    </div>
  );
}

14) Ãšltimas dicas rÃ¡pidas
. Sempre pense: estado local vs. lista. Se vocÃª quer vÃ¡rias entradas, guarde tudo em um array.
. Use value e onChange para sincronizar inputs com o estado.
. Atualize arrays com cÃ³pias ([...], map, filter), nunca mutando.
. Use id como key em vez de Ã­ndice quando possÃ­vel.
. Comece simples (Adicionar â†’ Remover â†’ Editar â†’ PersistÃªncia).












-->